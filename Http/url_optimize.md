---
title: 渲染优化
date: 2023-03-08 22:48:16
categories: 
- HTTP
---

# url渲染优化

## http1 --> http2
- **提升访问速度**(可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0)
- **允许多路复用**:多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限 制(连接数量)，超过限制会被阻塞
- **二进制分帧**:HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码
- **首部压缩**
- **服务器端推送**


## URL解析
  - 不超过 1kb
  - 嵌套结构不要太深

## DNS 查询
  - 浏览器缓存 --> 内存缓存 --> 路由缓存

  - prefetch 用于在浏览器的空闲时间请求资源
  - preload 用于提前加载在页面初始化加载（page load）时用到的资源
  - preconnect 用于提前和一个网站建立起连接(quicklink )

  - 对静态资源域名做手动dns-prefetch
  - 对js里发起的跳转、请求做手动的dns-prefetch
  - 对重定向跳转的新域名做手动的dns-prefetch
  - 不用对当前页面的超链接做手动的dns-prefetch

## TCP 连接
   **backlog**
   **somaxconn**

  - 调整SYN报文的重传次数
    - 第一次握手
    - 客户端作为主动发起连接方，首先它将发送 SYN 包，于是客户端的连接就会处于 SYN_SENT 状态。客户端在等待服务端回复的 ACK 报文，正常情况下，服务器会在几毫秒内返回 SYN+ACK ，但如果客户端长时间没有收到 SYN+ACK 报文，则会重发 SYN 包，重发的次数由 tcp_syn_retries 参数控制，默认是 6 次


  - 调整SYN半连接队列长度
    - 当服务端收到 SYN 包后，服务端会立马回复 SYN+ACK 包，表明确认收到了客户端的序列号，同时也把自己的序列号发给对方。
    此时，服务端出现了新连接，状态是 SYN_RCVD/SYN_RECV。在这个状态下，Linux 内核就会建立一个半连接队列来维护未完成的握手信息，当半连接队列溢出后，服务端就无法再建立新的连接。
    Tomcat、Nginx、Apache 都把自己的 listen backlog 参数设置为 511 


  - 调整SYN+ACK报文的重传次数
     - 第三次握手


  - 调整accpet队列长度
    - 连接完成
    - 服务器收到 ACK 后连接建立成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。
    -  如果进程不能及时地调用 accept 函数，就会造成 accept 队列（也称全连接队列）溢出，最终导致建立好的 TCP 连接被丢弃。
    - accept 队列的最大长度为 128

## HTTP 请求

  - 减少HTTP的请求的次数
  - 减少重定向请求次数；
  - 合并请求； 
  - 延迟发送请求；

  
  - 减少HTTP响应的数据的大小
  - ⽆损压缩； 有损压缩




## 响应请求

## 页面渲染

  - 一些不改变dom和css的js 使用 defer 和 async 属性告诉浏览器可以异步加载，不阻塞解析 。
  -  减少重绘和回流 
  - js尽量少访问dom节点和css 属性
  - 尽可能的为产生动画的 HTML 元素使用 fixed 或 absolute 的 position ，那么修改他们的 CSS 是不会 Reflow（回流） 的。
  - img标签要设置高宽，以减少重绘重排
  - 把DOM离线后修改，如将一个dom脱离文档流，比如display：none ，再修改属性，这里只发生一次回流。
  - 尽量用 transform 来做形变和位移，不会造成回流

  - 防抖节流
  - 拼接、合并、压缩、制作雪碧图
  - CDN资源分发
  - 缓存
  - 分片
  - 升级协议
  - Web Worker