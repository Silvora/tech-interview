---
title: V8浏览器引擎
date: 2025-01-17 10:25:34
categories: 
- JavaScript
---

# 面试官：说说V8浏览器引擎


## 一、是什么

`V8` 是一个由`Google`开发的开源 `JavaScript` 引擎，用于`Google Chrome` 及 `Chromium` 中，Node底层也使用了V8引擎

`CPU`并不认识我们的 `JS` 代码，而不同的`CPU`只认识自己对应的指令集，`JavaScript` 引擎将 `JS` 代码编译成CPU认识的指令集，当然除了编译之外还要负责执行以及内存的管理

`JS` 是解释型语言，由引擎直接读取源码，一边编译一边执行，这样效率相对较低，而编译型语言（如`c++`）是把源码直接编译成可直接执行的代码，执行效率更高

>@解释型语言：边解释，边执行
源代码 → 抽象语法树 → 解释器解释和执行
@编译型语言：先编译，再执行
源代码 → 抽象语法树 → 中间表示 → 本地代码

## 二、V8引擎原理

![](https://cdn.jsdelivr.net/gh/Silvora/oss@main/images/20250222233448765.webp)

![](https://cdn.jsdelivr.net/gh/Silvora/oss@main/images/20250222233817872.png)

### 解析与编译

- **解析器（Parser）：** `V8` 首先将 `JavaScript` 代码解析为抽象语法树`（AST）`。解析器分为预解析器和全解析器，预解析器快速扫描代码，识别函数和变量声明，而全解析器则生成详细的 `AST`。

- **解释器（Ignition）：** `V8` 使用 `Ignition` 解释器将 `AST` 转换为字节码。字节码是一种中间表示形式，比直接解释 `JavaScript` 代码更高效。


### 即时编译（JIT）

- **基线编译器（Baseline Compiler）：** `V8` 的基线编译器（`Turbofan` 的一部分）将字节码编译为机器码。基线编译器生成的代码优化程度较低，但编译速度快。

- **优化编译器（Optimizing Compiler）：** `V8 `的优化编译器（`Turbofan`）对热点代码（频繁执行的代码）进行深度优化，生成高效的机器码。优化编译器会进行内联缓存、类型推断等优化。

### 内联缓存（Inline Caching）

- `V8` 使用内联缓存来加速属性访问。当访问对象的属性时，`V8` 会缓存查找结果，下次访问相同属性时直接使用缓存，减少查找时间。


### 垃圾回收

- **分代垃圾回收：** `V8` 将内存分为新生代和老生代。新生代存放短期对象，使用 `Scavenge` 算法进行垃圾回收；老生代存放长期对象，使用标记-清除和标记-压缩算法。

- **并行和增量回收：** `V8` 的垃圾回收器支持并行和增量回收，减少主线程的停顿时间，提高应用响应速度。

### 隐藏类与内联缓存

- **隐藏类（Hidden Class）：** `V8` 为每个对象创建隐藏类，描述对象的结构。相同结构的对象共享隐藏类，减少内存使用并加快属性访问。

- **内联缓存：** `V8` 使用内联缓存加速方法调用和属性访问，缓存查找结果，减少重复查找。


### 优化策略

- **函数内联（Inlining）：** 将小函数调用替换为函数体，减少调用开销。

- **逃逸分析（Escape Analysis）：** 分析对象是否在函数外部被引用，决定是否在栈上分配对象。

- **类型反馈（Type Feedback）：** V8 收集代码执行时的类型信息，用于优化编译。


## 三、内存大小
node的运行内存大小和操作系统有关 
- 32位新生代的空间为32M,老生代为700M, 总大小为0.7G(32M+700M)
- 64位新生代的空间为64M,老生代为1400M, 总大小为1.4G(64M+1400M)
- node14之后修改为2G

## 四、垃圾回收机制

![](https://cdn.jsdelivr.net/gh/Silvora/oss@main/images/20250417203128451.PNG)

### 新生代（new space）
存放一些生命周期比较短的数据对象

- 新生代使用 copy复制,Scavenger算法(空间换时间,GC比较频繁)
  - 广度优先遍历From-Space中的对象，从根对象进行出发，广度优先遍历所有能达到的对象，把活的对象复制到To-Space
  - 遍历完成后，清空From-Space，并和To-Space角色互换
  - 复制后的对象在To-Space中占用的内存空间是连续的，不会出现碎片问题


### 老生代（old space）
存放一些生命周期比较长的数据对象

- 老生代使用标记整理清除,Mark-Sweep(标记清除),Mark-Compact(标记整理)
  - 新生代的对象转移到老生代称为晋升Promote,判断晋升的情况有两种
    - 经历一次GC还存活
    - 对象复制到To-Space时，To-Space的空间到达一定限制(>25%)
  - 比较大的对象直接分配到老生代里, 空间大, 存活久
  - Mark-Sweep(标记清除)
    - 出现内存溢出的问题(后续分配一个内存空间较多的对象时,内存不够用)
    - 出现内存碎片的问题(进行一次标记清除后，内存空间往往是不连续的)
  - Mark-Compact(标记整理)
    - 在标记清除的基础进行修改，将其的清除阶段变为紧缩极端, 为了解决标记清除所带来的内存碎片问题
    - 在整理的过程中，将活着的对象向内存区的一段移动，移动完成后直接清理掉边界外的内存
    - 紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片，一般10次标记清理会伴随一次标记整理
- 增量标记(自己优化)
  - 因为老生代对象又大又多，所以垃圾回收的时间更长，采用增量标记的方式进行优化
  - 增量标记就是把标记工作分成多个阶段，每个阶段都只标记一部分对象，和主线程的执行穿插进行
  - 为了支持增量标记，V8必须可以支持垃圾回收的暂停和恢复，所以采用了黑白灰三色标记法
  - 黑色表示这个节点被GC根引用到了，而且该节点的子节点都已经标记完成了
  - 灰色表示这个节点被GC根引用到了，但子节点还没被垃圾回收器标记处理，也表明目前正在处理这个节点
  - 白色表示此节点还没未被垃圾回收器发现，如果在本轮遍历结束时还是白色，那么这块数据就会被收回
  - 引入了灰色标记后，就可以通过判断有没有灰色节点来判断标记是否完成了，如果有灰色节点，下次恢复的应该从灰色执行
- Lazy Sweeping(惰性清理)
  - 当增量标记完成后，如果内存够用，先不清理，等js代码执行完慢慢清理
- Concurrent(并发回收)
  - 增量标记和惰性清理并没有减少暂停的总时间
  - 并发回收就是主线程在执行过程中，辅助线程可以在后台完成垃圾回收工作
  - 标记操作全部都由辅助线程完成，清理操作由主线程和辅助线程配合完成